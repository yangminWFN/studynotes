# 计算机网络

## 1、浏览器输入url到展示到页面上都做了些什么？

主要步骤有：

1. 浏览器解析url里的信息，包括使用的协议(http，https等)、域名、端口号（可能是默认端口号80，443）、资源路径
2. 使用DNS将域名解析为对应的IP地址
3. 根据IP地址和端口号与服务器发送消息，期间会用到TCP协议、ARP协议、OSPF协议等
4. 与客户端使用TCP协议使用三次握手建立连接
5. 建立连接后向服务器发送get请求
6. 服务器收到请求后，进行响应的业务处理后，将html页面信息返回给浏览器
7. 浏览器解析html文档，对其中的图片、js、css等资源文件再次发起请求；构建dom树，渲染css，执行js
8. 数据传输完毕后，使用四次挥手断开TCP连接

可以详细讲的点：

#### DNS解析过程：

1. 首先浏览器会查询浏览器是否缓存了域名和IP的对应关系，如果有就直接返回，如果没有进入2
2. 去找操作系统里的缓存（在windows上的hosts文件、linux系统一般是 /etc/hosts），如果有就直接返回，如果没有就进入3
3. 除了这两个地方有缓存外，还有路由器也会有缓存，本地域名服务器也会有缓存
4. 如果都没有找到缓存，就会让本地域名服务器向根域名服务器发送请求，获取com顶级域名服务器的IP地址
5. 获取到顶级域名服务器的IP地址后，再先顶级域名服务器发送请求获取baidu.com域名服务器的IP地址
6. 获取到之后就将IP地址缓存到本地域名服务器，并返回给浏览器，浏览器也将IP地址进行缓存

#### TCP三次握手过程：

初始化时，服务端处于监听状态，浏览器先服务器发起TCP连接请求

1. 客户端先服务器发送连接请求 同步SYN=1，序号seq=x，然后自己进入同步发送(SYN_SENT)状态
2. 服务器收到连接请求后，如果允许连接，就会先客户端返回一个 同步SYN=1，确认ACK=1，确认号ack=x+1，序号seq=y，服务端进入同步收到(SYN_RCVD)状态
3. 客户端收到请求后，向服务端发送确认ACK=1，确认号ack=y+1，序号seq=x+1，然后进入建立监听（ESTB_LISTEN）状态
4. 服务端收到这个确认请求后，自己也会进入建立监听（ESTB_LISTEN）状态

==这里为什么需要三次握手而不是两次？==

两个原因：

- 客户端发送的请求连接请求可能会由于网络原因在网路上滞留了，然后等待一个超时时间后，进行重传。但原来的连接请求和新的连接请求都到达了服务端，如果没有第三次握手的话，服务端将会多建立起一次不必要的连接。

- 客户端与服务端建立连接的主要目的是建立一个全双工通信，也就是要确保通信双方都直到对方和自己的发送和接收能力有没有问题。在第一次握手时，服务端知道了客户端的发送能力和自己的接收能力是没有问题的；在第二次握手时，客户端知道了自己的发送、接收能力和服务端的发送、接收能力是没有问题的；第三次握手时，服务端才可以知道自己的发送能力和客户端的接收能力是没有问题的。所以需要三次握手。

#### TCP四次挥手过程：

初始化时，客户端和服务端都处于建立监听（ESTB_LISTEN）状态，客户端主动与服务端发起断开连接请求

1. 客户端向服务端发送断开连接请求 终止FIN=1，序号seq=u，客户端进入终止等待状态的第一阶段(FIN_WAIT_1)
2. 服务端收到断开连接请求后，先客户端返回一个确认请求 确认ACK=1，确认号ack=u+1，序号seq=y，服务端进入关闭等待状态(CLOSE_WAIT)
3. 客户端收到服务端的确认请求后，自己将进入终止等待状态的第二阶段(FIN_WAIT_2)，此时客户端不能再向服务端发送任何数据。
4. 服务端等到自己剩下的数据发送完毕后，就向客户端发送断开连接请求 终止FIN=1，确认ACK=1，确认号ack=u+1，序号seq=w，然后进入最终确认状态(LAST_ACK)
5. 客户端收到服务端发送过来的断开连接请求后，就会向服务端返回一个确认请求 确认ACK=1，确认号ack=w+1，序号seq=u+1，并进入(TIME_WAIT)状态，等待两个最大报文存活时间后关闭连接。
6. 服务端收到客户端发过来的确认请求后就可以关闭连接了

==这里为什么需要四次握手？==

- 客户端向服务端发送断开连接请求后，服务端收到后会进入关闭等待状态。这个状态是为了让服务端处理完自己未发送完的数据，等到服务端发送完自己的数据后，服务端再主动给客户端发送断开连接请求。

==为什么客户端要等待2个最大报文存活时间？==

- 让本次连接的所有请求在网络中都消失，避免在下次连接中收到上一次连接里的请求
- 可能客户端向服务端返回的确认断开连接请求由于网络原因滞留了，服务端在等待一个超时重传时间后，会再次向客户端发送断开连接请求；如果此时客户端没有等待2个最大报文存活时间而是直接关闭的话，客户端将不再能够发送确认断开请求，服务端将处于无法关闭的状态

#### ARP协议

ARP协议（地址解析协议）主要解决的是同一个局域网下主机或路由器的IP地址和MAC地址的映射关系。如果源主机和目标主机在同一个局域网内（源主机ip和目标主机ip与子网掩码相与结果一致，则表示在同一个子网内），就可以使用ARP协议找到目标主机的MAC地址。如果不在一个局域网内的话，就会使用ARP找到本局域网内的一个路由器的MAC地址，然后使用路由器进行寻找。

==ARP工作流程：==

1. 每台主机上都有ARP高速缓存，存储着局域网内的各个主机和IP和MAC地址的映射关系。
2. 当源主机要向目标主机发送数据时，会首先在ARP高速缓存中找是否有目标主机IP地址对应的MAC地址，如果有则直接发送数据；如果没有，那么就会==向本局域网内的所有主机发送ARP请求分组==，数据包的内容有：源主机IP、源主机MAC地址、目标主机IP
3. 当本网络的所有主机收到这个ARP请求分组后，首先会检查请求信息里的目标主机IP是否是自己的IP；如果不是的话，则会忽略该数据包；如果是，那么就会将源主机的IP地址和MAC地址缓存到自己的ARP高速缓存中，然后向源主机返回一个ARP响应报文，向源主机返回自己MAC地址信息
4. 源主机收到这个MAC地址后，就会将这个MAC地址缓存到自己的ARP高速缓存里面，以后就根据这个MAC地址来向目标主机发送数据。如果没收到的话，则ARP查询失败。

#### 路由选择协议

如果在本局域网中没有找到目标IP对应的主机的MAC地址，则会通过本局域网中的一个路由器来查找其中的路由表信息决定如何到达目标服务器，期间可能经过多个路由器，这时候就会用到路由选择协议。

路由协议分内部网关协议和外部网关协议。内部网关协议在网络层有OSPF（开放式最短路径优先）使用了Dijkstra提出的最短路径算法，可以在多个路由器之间进行路由查询。



待补充：Tomcat收到请求，Filter、Servlet、SpringMVC拦截处理请求