# 2021秋招面经

## 一、百度提前批（20210716）

### 开场：

- 自我介绍（本科研究生就读学校，获奖情况）
- 项目技术栈，C#，没继续问了

### 技术问题：

- HashMap底层原理
- synchronized底层、锁升级过程
- 讲讲volatile、底层原理是什么（没答上来）
- 如何判断一个对象死亡了
- Redis常用的数据结构
- Redis持久化方式
- AOF重写过程
- zset的底层数据结构，跳表怎么实现
- 事务的隔离级别有哪些
- TCP四次挥手过程
- TCP首部都有哪些字段
- TCP的滑动窗口（没答上来）
- 进程和线程
- 进程间的通信方式有哪些

### 算法题（共享屏幕，用自己本地IDE写，需要自己定义数据结构和输入输出）

- 反转链表
- 二叉树的中序遍历（非递归）

### 反问：

- 校招基础重要还是分布式知识重要？

  答：基础重要

- 面试表现（还可以）

- 部门是做什么的

## 二、百度提前批二面

个人预测会问的东西：

### 网络：

- TCP与UDP区别，滑动窗口，TCP如何保证有序

  ```markdown
  TCP和UDP的区别？
  1.TCP是面向连接的、可靠交付的、传输数据格式是字节流的一种协议，它不支持广播和多播，需要使用三次握手建立连接，四次挥手断开连接，传输数据时还可以使用窗口、拥塞控制等控制传输速度，所消耗资源比较多。比较适合需要可靠传输的场景，例如文件传输、web请求等。应用层的HTTP和FTP等协议都是基于TCP的。
  2.UDP是不面向连接的、不可靠的、传输数据格式是用户数据报的一种协议，它支持广播和多播，在传输时不需要建立连接，比较适合通信速度比较快的场景。例如即时通信和域名转换都是基于UDP的。
  
  滑动窗口？
  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方都有一个窗口，接收方可以将自己的窗口大小通过TCP首部发送给发送方，发送方就可以根据这个窗口大小和其他信息设置自己的窗口大小。
  把字节流看成一个链表的话，发送方每次将窗口里的数据发送给接收方后，等待接收方确认后，就会将窗口向右进行滑动，直到左边第一个字节不是已发送被确认的字节为止；接收方窗口只会对窗口内最后一个按序到达的字节进行确认，发送方得到确认后，就知道自己应该从哪里开始继续发送了。
  
  TCP如何保证有序？
  首先应用层的数据会被分割成TCP适合发送的数据块，然后TCP的发送方就会给每个包进行编号，接收方接受到包后会按包的序号进行排序，而且在接收方的滑动窗口中只会接受窗口内最后一个按序到达的字节，这样也进一步保证了有序性。
  ```

- 三次握手四次挥手，各自的过程和原因，每个阶段客户端与服务端的状态

  ```markdown
  三次握手：
  初始时客户端要主动发起连接，此时服务端处于监听状态。
  1.客户端发送同步 SYN=1，序号seq=x，并进入SYN_SENT（同步发送）状态
  2.服务端收到请求后，如果允许连接，则向客户端返回 同步SYN=1,确认ACK=1，确认号ack=x+1,seq=y，并进入SYN_RCVD（同步收到）状态
  3.客户端收到请求后，向服务端返回 确认ACK=1，seq=x+1,确认号ack=y+1，并进入（ESTAB-LISTEN）建立监听状态
  为什么是三次握手？
  两个原因：
  原因1.从TCP连接的目的来讲，TCP连接主要是为了让两台主机上的进程进行数据传输，因此双方都要确认自己和对方的数据接受和发送能力是没有问题的。在第一次握手时，服务端知道了客户端的发送能力和自己的接收能力是没有问题的；第二次握手的时候，客户端知道了自己和服务端的接收和发送能力是没有问题的；只有再进行第三次握手，服务端才能知道客户端的接收能力和自己的发送能力是没有问题的，也就是双方都具有数据发送和接受能力。
  原因2.可能会由于网络原因，让第一次客户端发送的连接请求在网络中滞留了，然后等待一个超时重传时间后，客户端又发送了一个连接请求，这两个请求最终都会到达服务端，如果没有第三次握手，就会建立起两条连接。只有在进行第三次握手后，服务端才会忽略掉第一次旧的连接。
  
  四次挥手：
  初始时客户端和服务端都处于ESTAB_LISTEN（建立监听）状态
  1.客户端主动断开连接，向服务端发送 终止FIN=1，seq=u，然后进入FIN_WAIT-1(终止等待状态1)
  2.服务端收到请求后，向客户端发送 确认ACK=1，确认号ack=u+1,seq=v，然后进入CLOSE_WAIT(关闭等待)状态
  3.客户端收到请求后，进入FIN_WAIT-2(终止等待状态2),此时客户端不能再向服务端发送请求。
  4.服务端等自己处理完后，向客户端发送终止连接请求 终止FIN=1，确认ACK=1，确认号ack=u+1，seq=w，并进入LAST_ACK(最后确认)状态
  5.客户端收到请求后，向服务端返回一个确认请求 确认ACK=1，确认号ack=w+1，seq=u+1，并进入TIME—WAIT状态，等待2MSL（最大报文存活时间）后关闭连接。
  6.服务端收到客户端请求后，关闭自己的连接。
  为什么是四次挥手？
  客户端发送终止连接请求后，服务端收到这个请求，就会进入CLOSE_WAIT状态，这个状态是为了让服务端发送完自己还没发送完的数据，等待数据发送完毕后，服务端才会发送终止连接请求。
  客户端为什么要有一个WAIT_TIME状态，等待2MSL时间？
  原因1.确保客户端最后一个确认报文能够被服务端收到。如果客户端发送的确认报文因为网络原因滞留了，客户端此时还在等待时间内，服务端就可以再次发送终止连接请求，而不会导致服务端发送终止连接请求时，客户端已经关闭了。服务端无法关闭。
  原因2.等待本次连接中的所有请求的数据再网络中都消失，使得下一次连接中不会出现旧的连接请求报文。
  ```

- OSI七层模型

  ```markdown
  应用层：为应用程序提供数据传输服务，数据格式是报文。如Http、DNS等协议都是在应用层。
  表示层：提供数据压缩，加密解密，数据描述等服务，主要是解决各台主机中数据格式不同的问题。
  会话层：主要功能是创建和管理会话。
  传输层：传输层主要是为进程之间提供通用数据服务，数据格式是报文段。包括TCP传输控制协议（字节流）和UDP用户数据报协议（用户数据报）。
  网络层：为主机之间提供数据传输服务，数据格式是分组。主要协议是IP协议。
  数据链路层：各台主机之间可以有很多链路，数据链路层协议就是为同一条链路之间的主机提供数据传输服务，数据格式是帧。
  物理层：考虑的是如何在物理媒介中传输比特流，尽可能地屏蔽掉各种媒介和通信方式的差异，使链路层感觉不到有差异。
  ```

- TCP的粘包和拆包

- TCP的拥塞控制 

  ```markdown
  如果网络发生拥塞的话，分组大概率会丢失。这时候发送方会继续重传这些分组，就会导致网络的拥塞程度更严重。所以，在网络拥塞的时候，应该控制发送方发送的速率，这主要是为了降低整个网络的拥塞程度。TCP主要通过四个算法来进行拥塞控制，分别是：慢开始，拥塞避免，快重传和快恢复。
  慢开始和拥塞避免：发送方维护了一个叫拥塞窗口的状态变量cwd。开始发送时执行慢开始，将拥塞窗口cwd=1，等待收到确认后，将cwd进行翻倍，但是这样一直翻倍的话，会导致拥塞窗口会增长得特别快，所以又设置了一个阈值；当拥塞窗口大于阈值时，就每次只将cwd=cwd+1。如果发生超时的话，就会将阈值设为拥塞窗口的一半。
  快重传和快恢复：在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。在超时重传时会进行快恢复，将阈值设置为cwd的一半，cwd=阈值。
  ```

  

- http请求的过程？ 

  ```markdown
  1.根据当前URL的域名进行域名解析，在浏览器缓存、本地域名解析服务器缓存中查询是否有记录，如果有则直接返回域名对应的IP地址；如果没有的话就会让本地域名服务器向根域名服务器进行查询，如果没查到就会继续向上直到顶级域名服务器，然后再逐层返回得到IP地址。
  2.根据得到的IP地址和端口（http默认端口是80）生成一个套接字，向服务器进行TCP三次握手连接，建立连接后就可以进行数据发送了。
  3.服务端收到HTTP请求后，会根据自己的业务处理逻辑进行处理，生成一个HTTP响应报文返回给客户端。客户端如果没有设置长连接的话，就会进行TCP四次挥手来断开双方的连接。
  ```

- http和https的区别？https是如何加密的？ 

  ```markdown
  http和https的区别？
  1.URL中的协议名称不同，还有它们的默认端口也不同，http协议默认是80，而https协议默认是443
  2.http协议是运行在TCP之上的，传输内容都是明文，可以通过抓包工具进行抓取和解析，获取里面的详细信息，是不怎么安全的。https协议是在HTTP与TCP之间添加了一个SSL/TLS层，所有数据都是被加密过的，加密采用对称加密，但是用于对称加密的密钥使用服务器的证书进行了非对称加密，因此是比较安全的，但是由于每次要加密和解密所消耗的资源也会比较多。
  ```

- http状态码 

  ```markdown
  100	Continue	继续。客户端应继续其请求
  200	OK	请求成功。一般用于GET与POST请求
  201	Created	已创建。成功请求并创建了新的资源
  202	Accepted	已接受。已经接受请求，但未处理完成
  301	Moved Permanently	永久移动。
  302	Found	临时移动。
  304	Not Modified	未修改
  400	Bad Request	客户端请求的语法错误，服务器无法理解
  401	Unauthorized	请求要求用户的身份认证
  403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
  404	Not Found	服务器无法根据客户端的请求找到资源（网页）
  500	Internal Server Error	服务器内部错误，无法完成请求
  502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  ```

- get和post区别

  ```markdown
  1.GET把参数包含在URL中，POST通过request body传递参数
  2.GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok。
  3.GET请求在URL中传送的参数是有长度限制的，而POST在请求体里是没有长度限制的
  4.GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
  ```

- cors

  ```markdown
  CORS（跨域资源共享）它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。同源安全策略默认阻止“跨域”获取资源。但是 CORS 给了web服务器这样的权限，即服务器可以选择，允许跨域请求访问到它们的资源，三个与CORS请求相关的字段，都以Access-Control-开头。
  ```

- http请求完一次TCP层会立即关闭吗？

  ```markdown
  如果设置了长连接的话就会保持连接，不会立即关闭，这主要是为了防止网页上的每个资源都需要重新连接耗费资源。
  ```

- ARP协议

  ```bash
  地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理MAC地址的协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
  ```

  

### mysql：

- 四种隔离级别

  ```markdown
  读未提交、读已提交、可重复读、串行化
  ```

- 三种日志（binlog，undolog，redolog）各自作用

  ```markdown
  binlog:在mysql server层记录每次写操作的逻辑日志，每次以追加的方式进行写入，可以用来进行主从备份和数据恢复。
  redo log：是innodb中才有的日志文件，用来记录事务对具体物理页的修改。mysql 每执行一条 DML 语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file。使用大小固定，循环写入的方式。主要用于崩溃恢复，维持事务的持久性。
  undo log：事务原子性的底层实现就是依赖的undo log，undo log 也是 MVCC(多版本并发控制)实现的关键。
  ```

- MVCC是什么，有什么作用，怎么实现的

  ```markdown
  MVCC全称是多版本并发控制，是一种解决数据库中读写冲突的并发控制机制。它的实现主要依赖4个隐含字段和undo log和ReadView。4个隐含字段分别是隐含自增id、当前事务id、指向undolog中的这条记录的上一个版本的指针和删除标志位。
  事务对某条记录的每一次修改都会被记录到undolog中，形成一条修改链，而且链表的头节点就是离最新版本最近的一个版本的记录。Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID。Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。
  在RC隔离级别下，在一个事务中，每次对记录的快照读都会创建一个新的ReadView，所以它不能够解决不可重复读问题；而在RR隔离级别下，只有在第一次对对记录进行读取时会创建ReadView，后续的快照读都是使用的第一次的ReadView，所以读取到的都是同一个版本的数据。
  ```

- mysql索引原理，B树与B+树

  ```markdown
  1.B树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
  2.B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
  3.B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
  ```

- Innodb和MyISAM的区别

- int自增id的好处

- ACID

- 数据库建表规范，如何设计索引，三范式

  ```markdown
  1NF：主要是表中列的原子性。就是每一个属性不可再分。
  2NF：在1NF的基础上，每个表中都需要一个主键，且其他非主键必须完全依赖主键，而不能是部分依赖主键。
  3NF：在2NF的基础上，非主键列必须直接依赖主键列，而不能存在传递依赖
  ```

  

- 行锁，表锁，间隙锁，Next-Key锁

  ```markdown
  行锁主要解决的是多个事务对同一条记录的修改或删除问题，就是对某条记录进行加锁。可以是共享锁也可以是排他锁。
  表锁：就是对整个表进行加锁。在串行化隔离级别下，每次读写都会给表加表锁。
  间隙锁：主要被用来防止事务新增数据，导致幻读问题。可以锁住两边区间，配合行锁一起可以为Next-Key锁，解决RR级别下的幻读问题
  ```

  

- sql中where，group by，having，order by，limit，执行顺序

  ```markdown
  首先是对where中的条件进行过滤，得到一个结果集。然后对这个结果集进行groupby操作得到多个分组，然后使用having对所有分组进行一次过滤。然后再使用order by进行排序，最后使用limit取出相应的记录。
  ```

  

### redis：

- 常见五种数据类型，底层数据结构，各种数据结构适用场景

  ```markdown
  
  ```

- redis实现分布式锁

  ```markdown
  使用一条原子命令 set key value NX PX time来进行加锁，其中key和value是锁名称和客户端标识
  使用lua脚本来原子性解锁，首先判断该key是否是当前客户端标识，然后删除该key
  ```

- 使用redis的方式（旁路缓存策略）

  ```markdown
  查询：首先查询缓存，如果缓存中没有数据，那么就去数据库进行查询，然后将查询到的数据放到缓存中。
  更新数据：首先更新数据库，然后删除缓存或者更新缓存。否则会出现数据库和缓存数据不一致问题。
  ```

- 缓存穿透和雪崩，怎么解决

  ```markdown
  缓存穿透主要是由于同一时刻大量无效的Key直接越过缓存落到数据库上，导致数据库压力特别大。
  解决办法：必要的参数校验；在布隆过滤器中缓存所有可能出现的KEY，如果布隆过滤器判断key在缓存中，才走接下来的流程。如果判断不在，则直接返回错误信息。
  缓存雪崩：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。
  解决办法：设置不同的失效时间比如随机设置缓存的失效时间；
  缓存永不失效；
  采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
  限流，避免同时处理大量的请求
  ```

- 布隆过滤器有什么作用，原理

- redis集群，哨兵

- 过期策略、淘汰策略，默认淘汰策略

- ```markdown
  过期策略：
  惰性删除和定期删除结合。惰性删除就是在下次使用该Key的时候对其进行过期检查，如果过期了就将其删除。定期删除就是每隔一段时间就抽取一批Key进行过期删除操作。
  内存淘汰策略主要有8种：
  默认策略：noevication 内存不够就报错
  volatile-lru,volatile-lfu,volatile-random,volatile-ttl
  allkeys-lru,allkeys-lfu,allkeys-random
  其中：
  volatile-开头是针对设置了过期时间的key，allkeys就是针对所有的key
  ```

  

### 操作系统：

- 死锁的四个条件，怎么预防和破坏
- 生产者消费者模式实现（Java 信号量）
- 虚拟内存和物理内存
- 几种IO模型，IO多路复用中select和epoll的区别

### Java：

- Hashmap，CurrentHashMap

- 红黑树规则

- 线程池的参数，拒绝策略，执行流程

  ```markdown
  ThreadPoolExecutor.AbortPolicy：抛出 `RejectedExecutionException`来拒绝新任务的处理。
  ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
  ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。
  ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。
  ```

- AQS和ReetrantLock底层源码流程

  

- synchronize底层原理，锁升级过程，各种优化，（锁升级和锁消除，升级的哪一步会进行锁消除） 

- volatile作用，底层原理

- synchronized和volatile的区别

- 数组和链表，如何保证线程安全

- 面向对象的六大原则

### 设计模式：

- 单例模式（懒汉、饿汉、双重检验）
- 代理模式
- 工厂模式
- 模板方法模式
- 装饰者模式
- 适配器模式

### JVM：

- java内存区域，每一个部分的作用
- 虚拟机栈的组成？
- 垃圾回收算法，垃圾回收器
- 1.8默认的垃圾回收器
- CMS和G1垃圾回收器
- 如何判断一个对象死亡
- new对象的过程
- 类的加载过程
- 类加载器有哪些，Tomcat的类加载器
- 双亲委派机制的作用，如何打破
- 类加载用到jvm内存区域哪几块

### Spring：

- IOC作用，怎么实现的

- AOP作用，怎么实现的

- SpringMVC执行url的流程

  ```markdown
  1.用户发送请求至前端控制器DispatcherServlet
  2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。
  3.处理器映射器根据请求url找到具体的处理器，生成处理器执行链，一起返回给DispatcherServlet。
  4.DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作
  5.执行处理器Handler(Controller，也叫页面控制器)。
  6.Handler执行完成返回ModelAndView
  7.HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
  8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器
  9.ViewReslover解析后返回具体View
  10.DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。
  11.DispatcherServlet响应用户。
  ```

- SpringBoot与Spring的区别，自动配置原理

  ```markdown
  自动配置原理：主要是@SpringBootApplication里的@EnableAutoConfiguration注解
  @AutoConfigurationPackage 注解就是将主配置类（@SpringBootConfiguration标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器中，然后可以在META-INF/spring.factories这个文件中找到，将类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到 Spring 容器中，这样就实现了Springboot的自动配置。
  ```

  

- Bean的生命周期

  ```markdown
  
  ```

- Transactional实现

- 事务传播行为

### Mybatis：

- 分页原理

### linux命令：

- 查看进程端口，查看端口占用
- 修改权限
- 查看CPU和内存使用情况
- 查看java进程

### 消息队列：

背一些常见的问题和答案吧

### Spark：

背一点常见的问题和答案吧

### 算法：

- 约瑟夫环
- 上楼梯的所有路径
- 01背包
- 买卖股票
- TOPK
- 链表三等分点
- [leetcode](https://www.nowcoder.com/jump/super-jump/word?word=leetcode) 143