# 网易正式批

## 一、四道笔试题



## 二、比较重要的面试问题

### 1、在ArrayList中插入100W条数据的时间复杂度是多少？

```markdown
分两种情况
1、先扩容，使用ensureCapacity方法进行扩容，然后再插入，平均时间复杂度为 O(1)
2、直接一个个插入，每次到达阈值时都需要进行扩容成原来的1.5倍，平均时间复杂度为O(n)，可以使用等比数列求和的方式求得
```

### 2、Spring如何解决循环依赖的？

```markdown
循环依赖一般有三种：
1、构造器注入导致循环依赖：无法解决，会抛出异常。
2、非单例对象之间的循环依赖：无法解决，会导致无限创建对象，报OOM
3、单例对象的setter方式注入导致循环引用：三级缓存来解决
在Spring中初始化一个单例对象主要分为三步：
1、通过构造方法实例化这个对象createBeanInstance
2、属性填充（注入）populateBean
3、初始化Bean，调用Spring xml中配置的init-method方法
解决循环依赖，主要是在第二步，属性填充的时候解决的。
常见场景：在服务A中注入服务B，然后在服务B中注入A，都使用 @autowired方式注入并使用 @Service注解放入到容器中，因为Bean默认是单例的，这时候会出现单例模式的setter注入循环依赖。
使用三级缓存来解决这个问题，三级缓存分别是：
一级缓存：<beanName，instance>，用来存储初始化完成的单例对象 -> singletonObjects
二级缓存：<beanName，instance>，用来存储实例化完成，但是还未初始化的单例对象 -> earlySingletonObjects
三级缓存：<beanName，ObjectFactory>，用来存储实例化单例对象的对象工厂 -> singletonFactories
流程：
1、首先服务A使用构造函数完成实例化，然后将用于构建自己的对象工厂提前暴露在三级缓存中；
2、A进行属性填充操作，这时候会发现自己依赖B，就会尝试去一级、二级、三级缓存中去找B，都没有B，此时说明B还没有被创建，于是会先走创建B的流程
3、B在实例化后也会把用于构建自己的对象工厂提前暴露在三级缓存中，然后进行属性填充时发现自己依赖A，这时候就会尝试去一级、二级、三级缓存中去找A，发现只有三级缓存中有A的对象工厂，就会使用A的对象工厂的getObject对象来拿到A未初始化的对象，然后将A从三级缓存移到二级缓存中。
4、B这时候就拥有了A的引用，就可以进行后面的初始化流程，然后等到自己初始化完成后，将自己放入到一级缓存中并从其他缓存中移出。
5、此时返回A的属性填充流程，在一级缓存中就可以拿到B，完成自己后续的初始化工作，这样就解决了单例对象之间使用setter方式注入的循环依赖问题。
```

### 3、JVM调优问题

#### 3.1、如何找到某个进程中最占CPU的线程？（CPU列）占用CPU时间最长的线程？（TIME列）

使用命令 `top -Hp pid`查找到最占CPU的线程

<img src="images/image-20210830150700978.png" alt="image-20210830150700978" style="zoom: 67%;" />

==jstack用于查看某个进程内线程的堆栈信息。==

在上一步中，可以看到最占用CPU时间的线程id为113097

使用命令将其转化为十六进制 `printf "%x\n" 113097` 得到 `1b9c9`

然后使用 `jstack 113085 | grep 1b9c9`，其中113085是进程id，就可以输出是哪个线程的哪个方法最占用CPU时间了

<img src="images/image-20210830152018688.png" alt="image-20210830152018688" style="zoom:80%;" />

### 3.2、如何查看JVM堆内存使用情况

使用命令 `jmap -heap pid`

<img src="images/image-20210830152906836.png" alt="image-20210830152906836" style="zoom:67%;" />

### 4、