# 事务隔离级别演示

## 1. 读取未提交（read uncommitted）

![事务隔离级别-读取未提交演示](.\images\事务隔离级别-读取未提交演示.png)

**脏读：A事务读取到了B事务修改后没有提交的数据，B事务后面进行回滚将数据修改回原数据，但A事务后续操作依然使用的无效的数据**

## 2. 读取已提交（read committed）

![事务隔离级别-读取已提交演示](.\images\事务隔离级别-读取已提交演示.jpg)

**不可重复读：A事务 在B事务修改数据后未提交前读取到了一个数据，在B事务提交修改后又读取到一个数据，在同一个事务中两次读取到的数据不同**

# 3. 可重复读（repeatable read）

![事务隔离级别-可重复读演示](.\images\事务隔离级别-可重复读演示.jpg)

**可重复读：在A事务中读取到的数据始终都是一样的，不会被其他事务提交修改的数据所影响，是 mysql 中默认的隔离级别，解决了脏读、不可重复读和幻读问题；**

# 两个事务对同一数据并发修改

![两个事务并发修改](.\images\两个事务并发修改.jpg)

**两个事务对同一数据进行修改时，会有先后顺序，B事务会等待A事务修改完成后再进行修改**



==脏读、不可重复读都可以使用行锁来解决，但是幻读是针对insert操作的，无法给插入新的行加行锁。==



## mysql中解决幻读问题：间隙锁







## 多版本并发控制（MVCC）

