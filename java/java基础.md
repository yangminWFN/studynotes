# Java基础知识

1. 使用Arrays.asList()生成的List对象从根本上来讲还是数组，只能用于遍历集合或者随机读。不能add或者remove。（原因在于：在源码中返回的arrayList类对象不是public类ArrayList，而是Arrays类中的private内部类其继承自abstractList，里面没有重写add，remove等方法。所以调用时会去找abstractList中的方法）
2. 在集合中进行数据去重（增删）时，使用foreach和for循环遍历均有弊端，很容易产生错误！使用Iterator对象来进行修改最可靠！
3. 使用集合对象的listIterator遍历器对象可以向前或者向后的遍历集合，比Iterator要更加强大
4. 使用jar cvfe JarName.jar MainClassName *.class来打包可执行jar包，使用java -jar JarName.jar来执行。
      其中cvfe的fe参数不能颠倒，否则会导致主类和jar包名互调。
5. 在使用try-catch语句来捕获异常时，如果在try语句中抛出了catch语句中存在的异常类型对象时，将会立即停止执行try中代码跳入到对应catch语句块中。若在catch语句块中没有抛出新的异常，那么在catch语句块代码执行完毕后仍旧会执行后面的代码。若在catch语句中抛出了新的异常，那么就会立即终止catch语句块
6. 调用matcher的replaceAll或者replaceFirst方法都会导致内部的游标变化，过程就像先调用matcher.find()然后再替换。
7. matcher.region(0,testStr.length()-1);matcher.matches();可以测试在给定范围内的字符串是否完全匹配正则表达式；若匹配则为true
8. 如果调用matcher.matches()，不管返回是否为true，都会将游标指向最末尾的位置。所以在后面再调用find方法就总会返回false了
9. java中一个数字占一个字节，一个中文字占3个字节，一个换行符或者回车符占2个字节。（在文本文件中一行的结尾有4个字节\r\n）



# Java基础复习笔记

## 一、面向对象

封装、继承、多态（编译时，运行时）

## 二、Java数据类型

1. 基本类型（8种）
2. 包装类型（8种包装类型）
3. 自动装箱与拆箱
4. 包装类型缓存池是什么，在Java内存模型的哪个区域里，有什么用
5. 字符串常量池在哪里，本质是什么，intern()方法作用，1.6与1.7的区别

## 三、重写与重载

1. 区别点

## 四、Object类

1. equals方法，如何实现重写的equals方法，equals为什么要与hashcode一起重写
2. 如何深拷贝一个对象（除了实现Cloneable接口，重写Object类的clone()方法）

## 五、关键字

1. final（修改数据、方法、类）、static（修饰数据、方法、类、语句块）
2. 静态内部类和普通内部类的区别
3. 父类和子类初始化顺序

## 六、泛型

1. java泛型的实现、什么是类型擦除
2. 如何验证泛型的类型被擦除了（两种方式）
3. 类型擦除后保留的原始类型是什么（限定与非限定情况）
4. 使用泛型类，例如List时不指定泛型类型，会怎么样
5. Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译
6. 类型检查就是==针对引用==的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而==无关它真正引用的对象==
7. 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数
8. 继承泛型类型的类，==在编译器内部是生成了对应的桥方法来实现方法的重写（调用自己重写的方法）==，而不会因泛型类型擦除后变成了方法重载。



